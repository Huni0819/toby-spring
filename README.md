# Toby Spring 6 - 이해와 원리

토비의 스프링6 강의를 보고 학습한 내용을 정리한 레포지토리 입니다.

### 학습 환경

- Java 17
- Gradle - Groovy

## 섹션 2. 스프링 개발 시작하기

- 돈과 관련된 타입에서 Double을 사용할 경우 오차가 발생할 수 있다.
    - 정확한 계산을 위한 타입은 BigDecimal을 사용한다.

- 생성자를 사용하는 경우의 단점 ?
    - 파라미터로 정보를 나열할 때 같은 종류의 타입이 연속으로 나올 때 실수할 수 있음.
    - Setter ? Builder - Lombok ?

## 섹션 3. 오브젝트와 의존관계

- Java에서 Object는 Class의 Instance 또는 배열(Array)이다.

### Dependency - 의존 관계

- A -> B

1. 클래스 사이(코드 레벨)의 의존 관계 
   1. Client가 Supplier를 사용하면 의존하고 있다.
   2. Supplier가 변경되면 Client 코드가 영향을 받는다.
2. 오브젝트 사이의 의존 관계

- 클래스 사이의 의존 관계와 오브젝트 사이의 의존 관계가 다를 수 있다.

### 관심사의 분리 - Separation of Concerns (SoC)

1. 변경의 이유와 변경의 시점이 다른 코드를 같이 두는 것은 좋지 않다.
   1. 관심사를 분리하는 방법 중 메소드 추출 (Extract Method)

### 상속을 통한 확장

1. 재사용 관점에서 코드를 분리해야함. 
   1. 기존 코드의 기능을 수정하지 않고 기능을 사용하게 하기 위해서
2. 확장성 있는 코드를 만들 때 상속을 사용할 수 있음.

### 클래스의 분리

1. Payment를 준비하는 클래스와 환율 정보를 가져오는 클래스를 완전히 독립적인 클래스로 만들어보자.
   1. PaymentService가 ExRateProvider를 사용하는 사용 의존 관계가 만들어진다. 

### 인터페이스 도입

1. Provider를 바꿀 경우 코드의 변경이 일어났다.
   1. Provider가 제공하는 메소드의 이름이 다 제각각이기 때문에.
2. 독립적인 인터페이스를 만들어서 제공해야할 메소드의 이름을 통일한다.
3. 그럼에도 불구하고 PaymentService 코드의 수정(생성자)이 필요하기 때문에 결합도를 낮출 필요가 있다.

### 관계설정 책임의 분리

1. PaymentService는 인터페이스에만 의존한다.
   1. 하지만 우리가 원하지 않았지만 ExRateProvider의 구현체에 의존한다.
2. PaymentService가 어떤 구현체를 사용할 지 결정하는 과정을 **관계 설정**이라고 한다.
3. 의존관계를 설정하는 코드를 분리시킨다.

### 오브젝트 팩토리

1. Client는 두 개의 관심사를 가지고 있다.
   1. PaymentService를 이용하는 Client여야 하지만, Service가 다른 클래스 오브젝트와 어떻게 관계를 가져야 하는지 결정하는 책임도 함께 가지고 있다.
2. 관계 설정 책임을 ObjectFactory를 생성해 관계설정 책임에 충실한 코드를 작성한다.

### 원칙과 패턴

1. 제어의 역전 - Inversion of Control
   1. 제어권 이전을 통한 제어관계 역전
   2. PaymentService가 어떤 ExRateProvider를 사용할지 결정하는 권한을 가지고 있었지만, Client, ObjectFactory 순으로 제어권을 이전함.
   3. PaymentService가 동작하기 위해 필요로 하는 과정이지만 제어권을 이전했기 때문에 제어의 역전이라 함.
   4. 내가 권한을 가지고 하던 작업이 다른 쪽으로 넘어갔다.

### 스프링 컨테이너와 의존관계 주입

1. Spring Container?
   1. Spring의 여러 기능 중 가장 핵심이 되는 기능을 Spring Container라고 한다.
   2. IoC, DI를 제공
2. ObjectFactory에는 우리가 어떤 Object를 사용할지에 대한 정보가 들어있었다.
   1. Configuration
3. Dependency Injection
   1. 의존관계를 외부에서 주입해준다.

### 구성정보를 가져오는 다른 방법

1. @ComponentScan 어노테이션을 이용해서 @Component(@Service, @Controller, @Repository 등등) 어노테이션이 붙은 오브젝트를 Spring Bean으로 등록이 가능하다.

### 싱글톤 레지스트리

1. Spring Container의 독특한 특징
   1. Singleton Registry
      1. 스프링의 정체성
      2. 싱글톤 오브젝트를 등록해서 사용하도록 하는 것
   2. @Configuration 을 달아놓은 클래스는 메소드를 여러 번 호출하더라도 특별한 다른 지시가 없으면 오브젝트를 하나만 생성한다.
      1. proxy

### DI와 디자인 패턴

1. Class Pattern : 상속
2. Object Pattern : 합성
   1. 의존 관계 주입이 필요하다.

3. 환율 정보가 필요할 때 API를 호출해야 할까?
   1. 환율 정보가 필요한 기능들이 추가된 경우
      1. 상품 목록, 주문 처리
   2. 응답 시간 증가
      1. 환율 정보를 조회하는 오버헤드
   3. 환율 변동 주기
      1. 환율이 바뀌지 않는 시간에도 외부 API를 호출하는 것은 낭비 아닐까?
4. 환율 정보 캐시 (Cache) 도입
   1. WebApiExRateProvider 코드 수정?
   2. 디자인 패턴을 잘 응용하면 기존 코드의 수정없이 캐시 기능 추가가 가능하다.
5. Decorator 디자인 패턴
   1. 오브젝트에 부가적인 기능을 동적으로 부여한다.

### 의존성 역전 원칙

1. Dependency Inversion Principle (DIP)
   1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
   2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
2. 모듈?
   1. 전체 소프트웨어 시스템을 작은 단위로 쪼개어 놓은 것.
   2. 서로 긴밀하게 연관관계가 있는 응집도가 높고 결합도가 낮은 단위로 모아 둔 것.
   3. JAR 파일이 모듈, 패키지가 모듈의 기준이 될 수 있다.
3. 환율 정보를 가져오는 exrate 모듈, 정책과 서비스를 담당하는 payment 모듈로 분리.
   1. 정말 DIP를 준수하는 구조일까?
   2. 상위 모듈인 payment는 ExRateProvider를 의존하는 것은 맞지만,
   3. 여전히 payment 모듈은 하위 모듈을 의존하고 있다.
4. 인터페이스 소유권의 역전
   1. Separated Interface 패턴
   2. 인터페이스는 어느 패키지에 존재해야 하나?
      1. 상위 모듈로 ExrateProvider 인터페이스를 옮기면,
      2. 하위 ExrateProvider 구현체들이 상위 모듈의 추상화를 의존하는 자연스러운 구조가 된다.

## 섹션4. 테스트

### 자동으로 수행되는 테스트

1. 개발자가 만드는 테스트
   1. 개발한 코드에 대한 검증 기능을 코드로 작성한다.
   2. 테스팅 프레임워크 활용
   3. 테스트 코드도 개발 과정의 일부!!

### JUnit 테스트 작성

1. 테스트를 검증하려는 예제가 검증하는데 충분하지 않을 수 있다.
2. 테스트 코드를 작성할 때는 준비(given), 실행(when), 검증(then) 단계로 작성한다.

### PaymentService 테스트

1. 우리가 제어할 수 없는 외부 시스템에 문제가 생기면?
   1. WebExRateProvider는 환율 정보를 외부에서 받아오기 때문에
   2. ExRateProvider가 제공하는 환율 값으로 계산한 것인가?
   3. 환율 유효 시간 계산은 정확한가?

### 테스트의 구성 요소

1. 테스트 대상 (SUT - System Under Test)
2. 테스트
3. 협력자 (Collaborator)
   1. 의존 관계가 있는 다른 오브젝트

### 테스트와 DI

1. 수동 DI를 이용하는 테스트
   1. 의존 오브젝트를 테스트 대상에 직접 주입하고 테스트
2. 스프링 DI를 이용하는 테스트
   1. 스프링의 구성 정보를 이용해 컨테이너로부터 테스트 대상을 가져와 테스트

### 학습 테스트

1. 직접 만들지 않은 코드를 테스트 하는 것
2. 테스트 코드를 이용해서 동작방식을 확인하는데 유용
3. 외부 기술의 버전이 올라갔을 대 이전과 동일하게 동작하는지 확인 가능
4. 30분 뒤라는 시간이 정확하게 확인이 되는가?
   1. Clock 
   2. 테스트애서 우리가 테스트 목적으로 시계를 조작할 수 있다.

### 도메인 오브젝트 테스트

1. 도메인 모델 아키텍처 패턴?
   1. 도메인 로직, 비즈니스 로직을 어디에 둘 것인가?
   2. 서비스 메소드
   3. 도메인 모델 오브젝트
      1. 값만 가지고 있는게 아니라 기능을 수행하는 코드가 들어가야 한다.
2. Payment가 자기가 가지고 있는 정보로 계산을 수행하는 로직은 Payment 안에 기능이 들어가는게 낫다.