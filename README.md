# Toby Spring 6 - 이해와 원리

토비의 스프링6 강의를 보고 학습한 내용을 정리한 레포지토리 입니다.

### 학습 환경

- Java 21
- Gradle - Groovy

## 섹션 2. 스프링 개발 시작하기

- 돈과 관련된 타입에서 Double을 사용할 경우 오차가 발생할 수 있다.
    - 정확한 계산을 위한 타입은 BigDecimal을 사용한다.

- 생성자를 사용하는 경우의 단점 ?
    - 파라미터로 정보를 나열할 때 같은 종류의 타입이 연속으로 나올 때 실수할 수 있음.
    - Setter ? Builder - Lombok ?

## 섹션 3. 오브젝트와 의존관계

- Java에서 Object는 Class의 Instance 또는 배열(Array)이다.

### Dependency - 의존 관계

- A -> B

1. 클래스 사이(코드 레벨)의 의존 관계 
   1. Client가 Supplier를 사용하면 의존하고 있다.
   2. Supplier가 변경되면 Client 코드가 영향을 받는다.
2. 오브젝트 사이의 의존 관계

- 클래스 사이의 의존 관계와 오브젝트 사이의 의존 관계가 다를 수 있다.

### 관심사의 분리 - Separation of Concerns (SoC)

1. 변경의 이유와 변경의 시점이 다른 코드를 같이 두는 것은 좋지 않다.
   1. 관심사를 분리하는 방법 중 메소드 추출 (Extract Method)

### 상속을 통한 확장

1. 재사용 관점에서 코드를 분리해야함. 
   1. 기존 코드의 기능을 수정하지 않고 기능을 사용하게 하기 위해서
2. 확장성 있는 코드를 만들 때 상속을 사용할 수 있음.

### 클래스의 분리

1. Payment를 준비하는 클래스와 환율 정보를 가져오는 클래스를 완전히 독립적인 클래스로 만들어보자.
   1. PaymentService가 ExRateProvider를 사용하는 사용 의존 관계가 만들어진다. 

### 인터페이스 도입

1. Provider를 바꿀 경우 코드의 변경이 일어났다.
   1. Provider가 제공하는 메소드의 이름이 다 제각각이기 때문에.
2. 독립적인 인터페이스를 만들어서 제공해야할 메소드의 이름을 통일한다.
3. 그럼에도 불구하고 PaymentService 코드의 수정(생성자)이 필요하기 때문에 결합도를 낮출 필요가 있다.

### 관계설정 책임의 분리

1. PaymentService는 인터페이스에만 의존한다.
   1. 하지만 우리가 원하지 않았지만 ExRateProvider의 구현체에 의존한다.
2. PaymentService가 어떤 구현체를 사용할 지 결정하는 과정을 **관계 설정**이라고 한다.
3. 의존관계를 설정하는 코드를 분리시킨다.

### 오브젝트 팩토리

1. Client는 두 개의 관심사를 가지고 있다.
   1. PaymentService를 이용하는 Client여야 하지만, Service가 다른 클래스 오브젝트와 어떻게 관계를 가져야 하는지 결정하는 책임도 함께 가지고 있다.
2. 관계 설정 책임을 ObjectFactory를 생성해 관계설정 책임에 충실한 코드를 작성한다.

### 원칙과 패턴

1. 제어의 역전 - Inversion of Control
   1. 제어권 이전을 통한 제어관계 역전
   2. PaymentService가 어떤 ExRateProvider를 사용할지 결정하는 권한을 가지고 있었지만, Client, ObjectFactory 순으로 제어권을 이전함.
   3. PaymentService가 동작하기 위해 필요로 하는 과정이지만 제어권을 이전했기 때문에 제어의 역전이라 함.
   4. 내가 권한을 가지고 하던 작업이 다른 쪽으로 넘어갔다.

### 스프링 컨테이너와 의존관계 주입

1. Spring Container?
   1. Spring의 여러 기능 중 가장 핵심이 되는 기능을 Spring Container라고 한다.
   2. IoC, DI를 제공
2. ObjectFactory에는 우리가 어떤 Object를 사용할지에 대한 정보가 들어있었다.
   1. Configuration
3. Dependency Injection
   1. 의존관계를 외부에서 주입해준다.

### 구성정보를 가져오는 다른 방법

1. @ComponentScan 어노테이션을 이용해서 @Component(@Service, @Controller, @Repository 등등) 어노테이션이 붙은 오브젝트를 Spring Bean으로 등록이 가능하다.

### 싱글톤 레지스트리

1. Spring Container의 독특한 특징
   1. Singleton Registry
      1. 스프링의 정체성
      2. 싱글톤 오브젝트를 등록해서 사용하도록 하는 것
   2. @Configuration 을 달아놓은 클래스는 메소드를 여러 번 호출하더라도 특별한 다른 지시가 없으면 오브젝트를 하나만 생성한다.
      1. proxy

### DI와 디자인 패턴

1. Class Pattern : 상속
2. Object Pattern : 합성
   1. 의존 관계 주입이 필요하다.

3. 환율 정보가 필요할 때 API를 호출해야 할까?
   1. 환율 정보가 필요한 기능들이 추가된 경우
      1. 상품 목록, 주문 처리
   2. 응답 시간 증가
      1. 환율 정보를 조회하는 오버헤드
   3. 환율 변동 주기
      1. 환율이 바뀌지 않는 시간에도 외부 API를 호출하는 것은 낭비 아닐까?
4. 환율 정보 캐시 (Cache) 도입
   1. WebApiExRateProvider 코드 수정?
   2. 디자인 패턴을 잘 응용하면 기존 코드의 수정없이 캐시 기능 추가가 가능하다.
5. Decorator 디자인 패턴
   1. 오브젝트에 부가적인 기능을 동적으로 부여한다.

### 의존성 역전 원칙

1. Dependency Inversion Principle (DIP)
   1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
   2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
2. 모듈?
   1. 전체 소프트웨어 시스템을 작은 단위로 쪼개어 놓은 것.
   2. 서로 긴밀하게 연관관계가 있는 응집도가 높고 결합도가 낮은 단위로 모아 둔 것.
   3. JAR 파일이 모듈, 패키지가 모듈의 기준이 될 수 있다.
3. 환율 정보를 가져오는 exrate 모듈, 정책과 서비스를 담당하는 payment 모듈로 분리.
   1. 정말 DIP를 준수하는 구조일까?
   2. 상위 모듈인 payment는 ExRateProvider를 의존하는 것은 맞지만,
   3. 여전히 payment 모듈은 하위 모듈을 의존하고 있다.
4. 인터페이스 소유권의 역전
   1. Separated Interface 패턴
   2. 인터페이스는 어느 패키지에 존재해야 하나?
      1. 상위 모듈로 ExrateProvider 인터페이스를 옮기면,
      2. 하위 ExrateProvider 구현체들이 상위 모듈의 추상화를 의존하는 자연스러운 구조가 된다.

## 섹션4. 테스트

### 자동으로 수행되는 테스트

1. 개발자가 만드는 테스트
   1. 개발한 코드에 대한 검증 기능을 코드로 작성한다.
   2. 테스팅 프레임워크 활용
   3. 테스트 코드도 개발 과정의 일부!!

### JUnit 테스트 작성

1. 테스트를 검증하려는 예제가 검증하는데 충분하지 않을 수 있다.
2. 테스트 코드를 작성할 때는 준비(given), 실행(when), 검증(then) 단계로 작성한다.

### PaymentService 테스트

1. 우리가 제어할 수 없는 외부 시스템에 문제가 생기면?
   1. WebExRateProvider는 환율 정보를 외부에서 받아오기 때문에
   2. ExRateProvider가 제공하는 환율 값으로 계산한 것인가?
   3. 환율 유효 시간 계산은 정확한가?

### 테스트의 구성 요소

1. 테스트 대상 (SUT - System Under Test)
2. 테스트
3. 협력자 (Collaborator)
   1. 의존 관계가 있는 다른 오브젝트

### 테스트와 DI

1. 수동 DI를 이용하는 테스트
   1. 의존 오브젝트를 테스트 대상에 직접 주입하고 테스트
2. 스프링 DI를 이용하는 테스트
   1. 스프링의 구성 정보를 이용해 컨테이너로부터 테스트 대상을 가져와 테스트

### 학습 테스트

1. 직접 만들지 않은 코드를 테스트 하는 것
2. 테스트 코드를 이용해서 동작방식을 확인하는데 유용
3. 외부 기술의 버전이 올라갔을 대 이전과 동일하게 동작하는지 확인 가능
4. 30분 뒤라는 시간이 정확하게 확인이 되는가?
   1. Clock 
   2. 테스트애서 우리가 테스트 목적으로 시계를 조작할 수 있다.

### 도메인 오브젝트 테스트

1. 도메인 모델 아키텍처 패턴?
   1. 도메인 로직, 비즈니스 로직을 어디에 둘 것인가?
   2. 서비스 메소드
   3. 도메인 모델 오브젝트
      1. 값만 가지고 있는게 아니라 기능을 수행하는 코드가 들어가야 한다.
2. Payment가 자기가 가지고 있는 정보로 계산을 수행하는 로직은 Payment 안에 기능이 들어가는게 낫다.

## 섹션5. 템플릿

### 다시 보는 개방 폐쇄 원칙(OCP)

1. 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
2. DI
   1. 의존관계를 주입하는 책임을 외부에 두어야 한다.
3. 템플릿 ?
   1. 코드 중에서 `변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분`을 `자유롭게 변경되는 성질 = Callback`을 가진 부분으로부터 독립시켜 활용할 수 있도록 하는 방법.

### WebExRateProvider 리팩토링

1. 리팩토링?
   1. 기능을 변경하지 않고 구조를 개선하는 것
   2. 이해하기 쉽고 변경하기 쉬운 코드로 만드는 것
2. URL ?
   1. JDK 20 에서 Deprecated
   2. URL이 아니라 URI로 변경

### 변하는 코드 분리하기

1. 메소드 추출
   1. WebApiExRateProvider의 구성
      1. URI를 준비하고 예외처리를 위한 작업
      2. API를 실행하고, 서버로부터 응답을 가져오는 코드
      3. JSON 문자열을 파싱해 환율 정보를 추출하는 코드
   2. API를 호출하는 기술과 방법이 변경될 수 있다.
   3. 사용하는 API에 따라 JSON 구조와 정보 추출 방법이 변경될 수 있다.

### 변하지 않는 코드 분리하기

1. 목적을 위해 미리 만들어둔 모양이 있는 틀
2. 메소드 이름을 작성할 때 기능을 표현하기 보다 목적을 표현할 수 있는 이름을 사용하는게 더 좋다?
   1. parse -> extract

### ApiExecutor, ExRateExtractor 분리

1. API를 실행하는 기술과 기능을 담당하는 코드를 분리했다.
2. 하지만 메소드 분리만으로는 확장성이 떨어진다.
   1. 코드가 변경되면 전체 클래스가 변경됨!
3. 클래스로만 분리한다면 클래스간 강한 결합도를 가질 수 있다.
   1. interface 도입
4. Callback
   1. 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트
   2. 값을 참조하기 위한 목적이 아닌 특정 로직을 담은 메소드를 실행시키는 목적
5. 템플릿/콜백은 전략 패턴의 특별 케이스?
   1. 템플릿은 전략 패턴의 컨텍스트
   2. 콜백은 전략 패턴의 전략
   3. 콜백은 메소드 하나만 가진 전략 인터페이스를 사용 
6. Method Injection
   1. 메소드 호출 시점에 파라미터로 의존 오브젝트가 전달되는 방식
   2. DI의 한 종류

### ApiTemplate 분리

1. 환율 정보를 추출하는 기본 틀을 제공
   1. API 호출, 정보 추출의 기본 틀
2. 유사한 여러 오브젝트에서 재사용 가능

### 디폴트 콜백과 템플릿 빈

1. 콜백 메소드를 넣어주는 것보다 ApiTemplate에서 default callback method를 설정할 순 없을까?
   1. ApiTemplate의 기본 field 변수로 설정
   2. 메소드 오버로딩을 통해 구현
2. ApiTemplate 객체는 WebApiExRateProvider에서만 사용이 될까?
   1. 다른 모듈에서도 비슷한 기능을 사용하기 위해 템플릿을 사용할 수 있다.
   2. 애플리케이션 레벨에서 공유 가능한 오브젝트로 사용될까?
      1. 그렇다면 Spring Container 안에 Singleton Bean으로 등록해서 사용하는걸 고려해보자.
      2. 싱글톤으로 절대 사용하면 안되는 경우는 객체 안에 상태를 가지고 있을때
3. 그렇다면 ApiTemplate의 default callback을 바꾸고 싶으면?
   1. 매개변수가 있는 생성자를 정의해두어 Configuration 클래스에서 구성 정보를 변경해 사용할 수 있도록 하자.

> 템플릿 클래스를 만들 때 권장 사항
> 
> 디폴트 콜백이 의미가 있으면 기본적으로 설정하도록 하고
> 생성자를 통해서 변경해서 사용하는 걸 권장한다.

### 스프링이 제공하는 템플릿

1. RestTemplate
   1. HTTP API 요청을 처리
      1. HTTP Client 라이브러리 확장 - ClientHttpRequestFactory
      2. HttpMessageConverter 로 Message Body 변환
   2. ClientHttpRequestFactory
      1. SimpleClientHttRequest (HttpURLConnection)
   3. doExecute()
      1. 핵심 workflow를 가진 메소드
      2. RequestCallback
      3. ResponseExtractor

## 섹션6. 예외

### 예외를 다루는 방법

1. 예외?
   1. 정상적인 프로그램 흐름을 방해하는 사건
   2. 예외적인 상황에서만 사용
      1. 예외적인 상황이 아닌 내가 컨트롤하기 위한 기법으로 사용하는건 좋지 않다.
      2. try-catch를 이용해서 정상적인 값을 리턴하는 수단으로 사용하는 건 좋지 않다.
   3. 프로그램 오류, 버그 때문에 발생한다.
2. 예외처리?
   1. 예외를 처리할 때 `catch` 블록에서 예외를 무시하는건 좋지 않다.
      1. 로그를 남기는 것도 좋지만 예외를 밖으로 던져야 한다.
   2. 무책임하게 `throws`로 예외 처리를 넘기는건 좋지 않다.
3. Check Exception을 만나면
   1. RuntimeException이나 적절한 추상화 레벨의 예외로 전환해서 던질 것
4. 예외를 적절하게 추상화해서 사용하고 전환해서 사용해야 한다.
   1. 사용 기술마다 같은 문제에 대해서 다른 예외가 발생한다.

### JPA를 이용한 Order 저장

1. Unique 제약조건을 걸고 동일한 값을 넣으면 어떤 예외가 발생하는지?
   1. `org.hibernate.exception.ConstraintViolationException`
   2. 하지만 프로젝트에서 JPA가 아닌 다른 방식으로 변경된다면? ex ) 마이바티스, JDBC
2. `JDBC SQLException`
   1. JDBC를 기반으로 하는 모든 기술에서 발생하는 예외
   2. Spring에서는 예외를 추상화
3. `DataAccessException`
   1. exception translation 도구를 제공한다.
4. 기술의 변화가 애플리케이션 코드에 영향을 주지 않도록